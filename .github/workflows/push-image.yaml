# Name des GitHub Action Workflows
name: Build and Push Quarkus Application to GHCR

# Dieser Workflow wird bei jedem Push auf den 'main'-Branch ausgeführt.
# Du kannst dies anpassen, z.B. auf Pull Requests oder andere Branches.
on:
  push:
    branches:
      - main
  # Ermöglicht das manuelle Ausführen dieses Workflows von der Actions-Registerkarte aus
  workflow_dispatch:

# Umgebungsvariablen, die für alle Jobs im Workflow gelten
env:
  # Name des Docker-Images. Passe dies an deinen Projektnamen an.
  # Es wird im Format ghcr.io/DEIN_GITHUB_BENUTZERNAME/DEIN_PROJEKTNAME sein
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push-image:
    # Der Typ des Runners, auf dem der Job ausgeführt wird
    runs-on: self-hosted

    # Berechtigungen, die der GITHUB_TOKEN für diesen Job benötigt.
    # 'contents: read' zum Auschecken des Codes
    # 'packages: write' zum Hochladen des Docker-Images in die GHCR
    permissions:
      contents: read
      packages: write

    steps:
      # Schritt 1: Code aus dem Repository auschecken
      - name: Checkout repository
        uses: actions/checkout@v4

      # Schritt 2: Java JDK einrichten, um das Projekt zu bauen
      # Richtet eine Java-Version ein und konfiguriert den Maven-Cache
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'zulu'
          cache: maven

      # Schritt 3: Mit Maven bauen
      # Führt den Maven-Build aus, um die native ausführbare Datei zu erstellen.
      # Das '-Pnative' Profil ist entscheidend für den Quarkus Native Build.
      - name: Build with Maven
        run: mvn -B package -Pnative --file pom.xml

      # Schritt 4: An der GitHub Container Registry (ghcr.io) anmelden
      # Verwendet ein automatisch generiertes GITHUB_TOKEN zur Authentifizierung
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Schritt 5: Metadaten für das Docker-Image extrahieren (z.B. Tags und Labels)
      # Erstellt automatisch Tags basierend auf dem Git-Commit, Branch usw.
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ env.IMAGE_NAME }}

      # Schritt 6: Docker-Image bauen und in die GHCR hochladen
      # Dieser Schritt verwendet dein angepasstes Dockerfile.
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          # Der Kontext ist das Root-Verzeichnis deines Projekts
          context: .
          # Gibt an, dass das Image nach dem Bauen hochgeladen werden soll
          push: true
          # Verwendet die im vorherigen Schritt generierten Tags
          tags: ${{ steps.meta.outputs.tags }}
          # Verwendet die im vorherigen Schritt generierten Labels
          labels: ${{ steps.meta.outputs.labels }}
          # Aktiviert den Cache, um nachfolgende Builds zu beschleunigen
          cache-from: type=gha
          cache-to: type=gha,mode=max
